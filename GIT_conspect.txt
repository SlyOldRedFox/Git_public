С точки зрения Git, у файлов может быть 3 состояния:- Committed - файл хранится в базе данных- Modified - файл изменен, но не перемещен в базу данных- Staged - файл отмечен для помещения в базу данныхGit-проект можно условно разделить на 3 части:1) Рабочая директория - это распакованный снимок версии проекта. Эти файлы извлекаются из базы данных в рабочую директорию для того, чтобы можно было с ними работать.2) Staging область (индекс) - файлы, отмеченные для следующего коммита. Обычно содержатся в директории Git.3) Репозиторий (Git-директория или база данных) - наиболее значимая часть системы. В неё входят метаданные и объекты базы данных вашего проекта.    Когда клонируется репозиторий с другого компьютера, копируется эта часть.Рабочий процесс обычно выглядит так:- Файлы из рабочей директории модифицируются.- Добавляются файлы в stage область. В момент добавления в индекс переносится копия файлов на данный момент времени. Эта копия будет загружена при следующем коммите.- Происходит коммит, при этом берутся файлы из stage области, и в Git директории создается снимок, который останется там навсегда.ХранениеGit не рассматривает хранимые файлы как исходный файл и наборы изменений к ним. Вместо этого Git хранит информацию о файлах как серию снимков.Это похоже на отдельную файловую систему. Например, если в коммите присутствует новый файл, то Git добавляет ссылку на него.Если файл не изменился, то остается старая ссылка, а если изменился, то ссылка указывает на новый вариант файла.Если файл был удален, то ссылка просто удаляется, при этом сам файл остается в базе данных.Принцип локальностиТак как версия на клиенте и сервере дублируется, то в Git существует очень мало операций, для которых требуется подключение к серверу.Даже если в данный момент нет доступа к серверу, вы сможете работать с файлами локально, а изменения загрузить потом.ЦелостностьВ основе проверки корректности файлов лежит принцип хеширования. Для каждого файла формируется SHA-1 хеш, поэтому невозможна ситуация,когда из-за сбоя сети загрузится битый файл и вы об этом не узнаете. Аналогичным способом Git узнает о каждом изменении в файле.Информация хранится вечноКогда вы выполняете различные операции в Git, вы только добавляете информацию в базу данных. Существует очень мало операций, которые нарушают это правило.Когда вы делаете коммит, то информация добавляется в базу данных Git. Если файл физически удаляется из рабочей директории, то в базе данных он все равно останется,а удалится только ссылка на него в снимке текущей версии. Если вы измените файл, в базу данных Git добавится новый объект, старый при этом останется.Таким образом, существует очень мало сценариев, по которым вы можете потерять информацию или сделать что-то с невозможностью откатиться назад.Настройкаgit config user.name "Username"git config user.email "username@somemail.com"Флаг -global добавленный к командам выше позволит сохранить эти настройки для всех проектов:git config --global user.name "Username"git config --global user.email "username@somemail.com"Инициализация проектаДля начала работы зайдите в вашем терминале в директорию, в которой собираетесь использовать Git и выполните команду git init,вы увидите сообщение похожее на это:Initialized empty Git repository in D:/webdev/git/first-use/.git/Данная команда создала скрытую директорию .git, в этой директории будут храниться версии файлов и с помощью неё обеспечиваетсявесь связанный с контролем версий функционал.git addgit add [filename]Добавляет выбранные версии файлов в staging область для последующего коммита.git add .Добавляет все файлы в очередь для последующего коммита.git commitgit commit -m "this is comment"Создает коммит с комментарием после ключа -m. Предварительно должны быть указанны с помощью git add файлы.git commit -am "this is another comment"Если не указать файлы командой git add, то команда git commit не создаст коммит.Эти два действия можно объединить, указав ключ -a. Данный ключ показывает,что нужно создать коммит всех измененных файлов, учитывая удаленные,но при этом новые файлы (которых еще нет в индексе) учитываться не будут.Pull и PushРассмотрим команды pull и push на практическом примере. Создадим на гитхабе новый тестовый проект (с файлом readme).Затем создадим директорию на своём компе, инициализируем в ней Git, и выполним команды remote add и pull:git initgit remote add origin https://github.com/AntKondr/test-projectgit pull origin masterТаким образом мы создали директорию и инициализировали в ней локальный репозиторий.С помощью команды remote add origin при привязали локальный репозиторий к удаленному.А с помощью команды git pull origin master были скопированы файлы (в данном случае файл readme) с удаленного репозитория на локальный из ветки origin master.Теперь откроем файл README.md из локальной директории, добавим туда что-нибудь и выполним следующие команды:git add .git commit -m "test push"git push origin masterСистема запросит указать имя пользователя и пароль. После успешной авторизации изменения будут загружены на удаленный репозиторий в указанную ветку.Подведем итог:- git push — добавляет данные на удаленный сервер с локального компьютера- git pull — забирает данные на локальный компьютер с удаленного сервераCloneКлонирование существующего репозитория осуществляется с помощью команды git clone <url>, например:git clone https://github.com/libgit2/libgit2 Команда создаст репозиторий в текущей директории.Команду clone можно использовать как короткий вариант, заменяющий серию команд:mkdir test-projectcd test-projectgit initgit remote add origin https://github.com/ValeriyDyachenko/test-projectgit pull origin masterBranchВетви позволяют работать одновременно над несколькими версиями репозитория.По умолчания, после создания проекта в нем присутствует единственная ветвь master.С помощью ветвей вы можете вносить свои вариации и правки, тестировать их, а потом объединять с главной ветвью.Когда вы создаете новую ветвь, создается копия master ветви. В процессе работы над своей ветвью,ветвь master может обновиться кем-то. В таком случае, вы можете забрать эти изменения в свою ветвь,с помощью команды pull.Создать ветвь:git branch newbranchПерейти в ветвь:git checkout newbranchСоздать ветвь и сразу же в неё перейти:git checkout -b newbranchЕсли нужно загрузить новую ветвь на сервер, выполните команду:git push origin newbranchДопустим, вы внесли все изменения в созданную ветвь, протестировали их, и теперь хотите объединить эту ветвь с основной.Для этого запустите следующие команды (и затем выполните push запрос):git checkout mastergit merge newbranchКогда ветви объединены и изменения перенесены в основную ветку, вам больше не нужна дополнительная ветвь.Для того, чтобы удалить её, перейдите в другую ветвь и выполните команду:git branch -d newbranchЭто удалит ветвь из локального репозитория.Для удаления ветви из удаленного репозитория выполните команду:git push -d origin newbranchПросмотр старых версий проектаЕсли возникла необходимость посмотреть как выглядел тот или иной файл в определенный момент развития проекта,то сделать это очень просто.Посмотрите лог и скопируйте id интересующего коммита:git logЗатем выполните команду checkout для данного коммита, например:git checkout bc9f07bbadb153d88a4daa3bd21aafe054b15055С этого момента рабочая область проекта изменится и вы можете работать с этими версиями файлами.При необходимости, можно создать новую ветку с помощью рассмотренной ранее команды:git checkout -b [your-new-branch-name]Для того, чтобы вернуться к последней версии коммита из главной ветки, напишите команду:git checkout masterОбратите внимание, что когда вы находитесь в предыдущей версии коммита с помощью команды checkout,то команда git log покажет лог только до текущего коммита, в котором вы находитесь.Чтобы увидеть все коммиты воспользуйтесь командой:git reflogЕсть возможность перейти к определенной версии проекта, удалив при этом последующие коммиты.Но этот вариант не рекомендуется, так как изменения будут потеряны:git reset --hard [commit-id]StatusПосмотреть текущую ветку, незакоммиченные файлы и другую информацию:git statusКонтрибьютРекомендации, которые помогут сделать хороший pull request в открытый GitHub проект:1) Вы должны быть зарегистрированы на GitHub. После этого, зайдите в заинтересовавший вас проект и нажмите кнопку fork.    Теперь на вашей странице в GitHub добавился новый проект.2) Скопируйте свой fork на локальную машину с помощью команды:    git clone https:/github.com/your_name/repo    ВАШ удалённый *fork-репозиторий* называется 'origin'.3) Добавьте ссылку на ИСХОДНЫЙ проект, чтобы можно было актуализировать ваш код, выполните:    git remote add upstream <url репо который форкнули>    Теперь вы можете выполнять pull запросы с репа который форкнули, например:    git pull upstream master    удалённый исходный репозиторий называется 'upstream'.4) Создайте ветку для работы. Если в проекте есть ветка для разработчиков, скопируйтесь с нее, иначе с master.5) Внесите свои доработки и сделайте коммит. Придерживайтесь стиля кода, который принят в проекте.6) Если в проекте есть тесты, запустите их. При необходимости напишите свои.7) Внесите правки в документацию, если это необходимо.8) Теперь нужно объединить все коммиты в один. Чтобы посмотреть список коммитов можно воспользоваться командой:    git log --graph --decorate --pretty=oneline --abbrev-commit    Затем воспользуйтесь командой на выбор    git rebase -i HEAD~[номер коммита]    или    git rebase -i [SHA]    Данная команда запускает интерактивный режим, в котором можно реорганизовать коммиты. Вы увидите текстовый файл с содержанием, отражаемым выбранные коммиты:    pick b8e4605 comment    pick e04f243 comment    pick e3950bb comment    pick 5c8f591 comment    pick c7f3446 comment    Чтобы объединить коммиты в один, отредактируйте файл следующим образом:    pick b8e4605 comment    squash e04f243 comment    squash e3950bb comment    squash 5c8f591 comment    squash c7f3446 comment9) Сделайте коммит в ваш гитхаб fork проект с помощью команды    git push origin <branch_name>10) Выполните pull request из вашего fork проекта.11) После того, как ветка будет принята и слита с основной, можно выполнить pull с upstream в локальном репозитории и удалить старые ветки.